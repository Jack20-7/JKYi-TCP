每一个结构体加上一个__attribute__((packed))的目的就是避免编译器对struct进行内存对齐
unsigned short 的大小是2个字节，16位

关于地址结构体的管理，采用的是池式的结构体.并且还利用了RSS,RSS是一种网络驱动程序技术，可在多处理器系统中的多个CPU之间有效分配网络接收处理.它在多个基于硬件的接收队列之间分配网络接收处理，从而允许多个CPU处理入站网络流量。RSS可用于缓解单个CPU过载导致的接收中断处理瓶颈，并减少网络延迟.

柔性数组，也成为零长数组.它一般使用在以分配好内存并且大小可以通过计算出的场景.我们可以其实就可以将他看作是数组指针,只是使用起来需要有条件限制

我们通过ifcofig显示出的比如eth0它其实是linux内核网络子系统实例化出的一个网卡对象，它里面存储的信息就是对于的某一个网卡的信息.

网卡的主要作用就是进行AD转换，它位于物理层和数据链路层之间

轮询和事件的抉择的话，如果是大量数据的情况下，其实轮询是要优于事件的.

当被动断开连接方收到主动断开连接方发送来的fin之后，就知道主动断开连接方不会在发送数据包过来了，但是对于目前的那些还在接收缓冲区以及还在网络中传输的报文，依然会照常接收

epoll在设计的时候，它要管理的文件描述符的状态一共分为两种，分别是空闲状态和就绪状态.并且绝大多数fd都是处于空闲状态的，只有小部分属于是就绪状态.所以对于这两个集合的管理的，
如果是空闲状态的fd集合，在设计的时候，考虑到的数据结构有:
1.hash结构 (查找效率高，但是不利于拓展)
2.红黑树 (查找、增加和删除的时间复杂度都是logn)
3.B/B+树 (由于B/B+树它每一个节点可以存储多个元素以及每一个节点拥有多个子节点的特性，它的层数要远小于红黑树的，它适合用在磁盘操作的场景.不适合用在内存操作操作,节点比较大);
所以综合下来，对于空闲fd集合的管理，采用的是红黑树

对于就绪fd集合的管理的话，由于涉及到的元素比较少,并且对于空闲的fd，要做的操作主要就是插入和删除,所以使用队列来管理是最佳的,之所以不使用栈是为了保证先进先出的特性，如果使用栈可能会导致某些事件一直不被处理.

epoll和协议栈配合的方式就是:
1.协议栈内部在实现的时候，当全连接队列中中出现新的stream时，会通过回调函数来通知读事件
2.recvbuf中接收到新数据之后，会调用回调函数通知读事件
3.sendbuf中有空闲空间二点时候，会调用回调函数通知写事件
4.协议栈收到fin报文之后，会调用回调函数通知读事件

gcc在将源文件编译成目标文件的时候，对于函数的话，只需要有声明就够了，但是在通过.o文件链接生成可执行文件的时候，就会去寻找函数的时候，如果没有就会报错.


